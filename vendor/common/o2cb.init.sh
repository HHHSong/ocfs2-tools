#!/bin/bash
# init fragment for O2CB.
#
# chkconfig: 2345 24 20
# description: Load O2CB cluster services at system boot.
#
### BEGIN INIT INFO
# Provides: o2cb
# Required-Start: $network
# Should-Start:
# Required-Stop:
# Default-Start: 2 3 5
# Default-Stop:
# Description: Load O2CB cluster services at system boot.
### END INIT INFO

# Force LC_ALL=C
export LC_ALL=C

# Let's try to use the LSB functions
. /lib/lsb/init-functions
if [ $? != 0 ]
then
    echo "Unable to load LSB init functions" >&2
    exit 1
fi

CLUSTERCONF=/etc/ocfs2/cluster.conf
STACKCONF=/var/run/o2cb.stack

if [ -f /etc/sysconfig/o2cb ]
then
    # Red Hat and Novell
    CONFIGURATION=/etc/sysconfig/o2cb
elif [ -f /etc/default/o2cb ]
then
    # Debian
    CONFIGURATION=/etc/default/o2cb
elif [ -d /etc/sysconfig ]
then
    CONFIGURATION=/etc/sysconfig/o2cb
else
    CONFIGURATION=/etc/default/o2cb
fi

# How long to wait to start things
BRINGUP_TIMEOUT=5

# The default values should always be in sync with the kernel
DEF_HEARTBEAT_THRESHOLD=31
DEF_IDLE_TIMEOUT_MS=30000
DEF_KEEPALIVE_DELAY_MS=2000
DEF_RECONNECT_DELAY_MS=2000

# Minimum timeout values
MIN_HEARTBEAT_THRESHOLD=7
MIN_IDLE_TIMEOUT_MS=5000
MIN_KEEPALIVE_DELAY_MS=1000
MIN_RECONNECT_DELAY_MS=2000

CMAN_SUPPORTED=@@CMAN_SUPPORTED@@
[ "$CMAN_SUPPORTED" != "yes" ] && CMAN_SUPPORTED=

# Source configuration, 
[ -f "${CONFIGURATION}" ] && . "${CONFIGURATION}"
# Need this default
[ -z "$O2CB_STACK" ] && O2CB_STACK=o2cb

configfs_path()
{
    # Note that this is only valid *after* configfs is loaded
    if [ -d /sys/kernel/config ]
    then
        echo /sys/kernel/config
    else
        echo /config
    fi
}


#
# if_fail()
#
# Evaluates return codes.  If 0, prints "OK", if 1, prints "Failed"
# and exits.  If 2, status is "already done" and nothing is printed.
# The rest of the functions in here all honor this convention.
#
if_fail()
{
    RC="$1"
    REASON="$2"
    if [ "$RC" = "0" ]
    then
        echo "OK"
        return
    elif [ "$RC" = "2" ]
    then
        return
    fi
    echo "Failed"
    if [ -n "${REASON}" ]
    then
        echo "${REASON}" >&2
    fi
    exit 1
}


#
# write_sysconfig()
#
# Writes the system configuration out
#
write_sysconfig()
{
    echo -n "Writing O2CB configuration: "
    cat >"${CONFIGURATION}" <<EOF
#
# This is a configuration file for automatic startup of the O2CB
# driver.  It is generated by running /etc/init.d/o2cb configure.
# Please use that method to modify this file
#

# O2CB_ENABELED: 'true' means to load the driver on boot.
O2CB_ENABLED=${O2CB_ENABLED:-false}

# O2CB_STACK: The name of the cluster stack backing O2CB.
O2CB_STACK=${O2CB_STACK}

# O2CB_BOOTCLUSTER: If not empty, the name of a cluster to start.
O2CB_BOOTCLUSTER=${O2CB_BOOTCLUSTER}

# O2CB_HEARTBEAT_THRESHOLD: Iterations before a node is considered dead.
O2CB_HEARTBEAT_THRESHOLD=${O2CB_HEARTBEAT_THRESHOLD}

# O2CB_IDLE_TIMEOUT_MS: Time in ms before a network connection is considered dead.
O2CB_IDLE_TIMEOUT_MS=${O2CB_IDLE_TIMEOUT_MS}

# O2CB_KEEPALIVE_DELAY_MS: Max time in ms before a keepalive packet is sent
O2CB_KEEPALIVE_DELAY_MS=${O2CB_KEEPALIVE_DELAY_MS}

# O2CB_RECONNECT_DELAY_MS: Min time in ms between connection attempts
O2CB_RECONNECT_DELAY_MS=${O2CB_RECONNECT_DELAY_MS}

EOF

    if [ $? != 0 ]
    then
        return 1
    fi
    return 0
}

#
# read_timeout()
#   Returns timeout value provided by user to caller in RET_VAL
#
read_timeout()
{
    if [ "$#" -lt "4" ]; then
        echo "read_timeout(): Requires more arguments" >&2
        exit 1
    fi

    ATTRIB_NAME=$1
    ATTRIB_VAL=$2
    MIN_ATTRIB_VAL=$3
    DEF_ATTRIB_VAL=$4
    RET_VAL=0

    while :
    do
        if [ -z $ATTRIB_VAL ]; then
            CUR=$DEF_ATTRIB_VAL
        else
            CUR=$ATTRIB_VAL
        fi
        echo -n "Specify ${ATTRIB_NAME} (>=$MIN_ATTRIB_VAL) [$CUR]: "
        read LINE
        case "$LINE" in
        "")
            RET_VAL="$ATTRIB_VAL"
            break
            ;;

        *[^0-9]*)
            echo "Invalid ${ATTRIB_NAME} value: $LINE" >&2
            ;;
        *)
            if [ $LINE -lt $MIN_ATTRIB_VAL ]; then
                echo "${ATTRIB_NAME} cannot be less than $MIN_ATTRIB_VAL" >&2
            else
                RET_VAL="$LINE"
                break
            fi
            ;;
        esac
    done
}

set_timeouts()
{
    O2CB_HEARTBEAT_THRESHOLD_FILE_OLD=/proc/fs/ocfs2_nodemanager/hb_dead_threshold
    O2CB_HEARTBEAT_THRESHOLD_FILE=$(configfs_path)/cluster/${CLUSTER}/heartbeat/dead_threshold
    if [ -n "$O2CB_HEARTBEAT_THRESHOLD" ]; then
        if [ -f "$O2CB_HEARTBEAT_THRESHOLD_FILE" ]; then
            echo "$O2CB_HEARTBEAT_THRESHOLD" > "$O2CB_HEARTBEAT_THRESHOLD_FILE"
        elif [ -f "$O2CB_HEARTBEAT_THRESHOLD_FILE_OLD" ]; then 
            echo "$O2CB_HEARTBEAT_THRESHOLD" > "$O2CB_HEARTBEAT_THRESHOLD_FILE_OLD"
        fi
    fi

    O2CB_IDLE_TIMEOUT_MS_FILE=$(configfs_path)/cluster/${CLUSTER}/idle_timeout_ms
    if [ -n "$O2CB_IDLE_TIMEOUT_MS" ]; then
        if [ -f "$O2CB_IDLE_TIMEOUT_MS_FILE" ]; then
            echo "$O2CB_IDLE_TIMEOUT_MS" > "$O2CB_IDLE_TIMEOUT_MS_FILE"
        fi
    fi

    O2CB_KEEPALIVE_DELAY_MS_FILE=$(configfs_path)/cluster/${CLUSTER}/keepalive_delay_ms
    if [ -n "$O2CB_KEEPALIVE_DELAY_MS" ]; then
        if [ -f "$O2CB_KEEPALIVE_DELAY_MS_FILE" ]; then
            echo "$O2CB_KEEPALIVE_DELAY_MS" > "$O2CB_KEEPALIVE_DELAY_MS_FILE"
        fi
    fi

    O2CB_RECONNECT_DELAY_MS_FILE=$(configfs_path)/cluster/${CLUSTER}/reconnect_delay_ms
    if [ -n "$O2CB_RECONNECT_DELAY_MS" ]; then
        if [ -f "$O2CB_RECONNECT_DELAY_MS_FILE" ]; then
            echo "$O2CB_RECONNECT_DELAY_MS" > "$O2CB_RECONNECT_DELAY_MS_FILE"
        fi
    fi
}

show_timeouts()
{

    O2CB_HEARTBEAT_THRESHOLD_FILE_OLD=/proc/fs/ocfs2_nodemanager/hb_dead_threshold
    O2CB_HEARTBEAT_THRESHOLD_FILE=$(configfs_path)/cluster/${CLUSTER}/heartbeat/dead_threshold
    if [ -f "$O2CB_HEARTBEAT_THRESHOLD_FILE" ]; then
        VAL=`cat "$O2CB_HEARTBEAT_THRESHOLD_FILE"`
        echo "Heartbeat dead threshold = ${VAL}"
    elif [ -f "$O2CB_HEARTBEAT_THRESHOLD_FILE_OLD" ]; then
        VAL=`cat "$O2CB_HEARTBEAT_THRESHOLD_FILE_OLD"`
        echo "  Heartbeat dead threshold: ${VAL}"
    fi

    O2CB_IDLE_TIMEOUT_MS_FILE=$(configfs_path)/cluster/${CLUSTER}/idle_timeout_ms
    if [ -f "$O2CB_IDLE_TIMEOUT_MS_FILE" ]; then
        VAL=`cat "$O2CB_IDLE_TIMEOUT_MS_FILE"`
        echo "  Network idle timeout: ${VAL}"
    fi

    O2CB_KEEPALIVE_DELAY_MS_FILE=$(configfs_path)/cluster/${CLUSTER}/keepalive_delay_ms
    if [ -f "$O2CB_KEEPALIVE_DELAY_MS_FILE" ]; then
        VAL=`cat "$O2CB_KEEPALIVE_DELAY_MS_FILE"`
        echo "  Network keepalive delay: ${VAL}"
    fi

    O2CB_RECONNECT_DELAY_MS_FILE=$(configfs_path)/cluster/${CLUSTER}/reconnect_delay_ms
    if [ -f "$O2CB_RECONNECT_DELAY_MS_FILE" ]; then
        VAL=`cat "$O2CB_RECONNECT_DELAY_MS_FILE"`
        echo "  Network reconnect delay: ${VAL}"
    fi
}

#
# configure_ask()
#
# Ask configuration questions, setting the shell vars.
#
configure_ask()
{
    cat <<EOF
Configuring the O2CB driver.

This will configure the on-boot properties of the O2CB driver.
The following questions will determine whether the driver is loaded on
boot.  The current values will be shown in brackets ('[]').  Hitting
<ENTER> without typing an answer will keep that current value.  Ctrl-C
will abort.

EOF

    while :
    do
        if [ "$O2CB_ENABLED" = "true" ]
        then
            CUR=y
        else
            CUR=n
        fi
        echo -n "Load O2CB driver on boot (y/n) [$CUR]: "
        read LINE
        case "$LINE" in
        "")
            break
            ;;
        y|Y)
            O2CB_ENABLED=true
            break
            ;;
        n|N)
            O2CB_ENABLED=false
            break
            ;;
        *)
            echo "Invalid answer: $LINE" >&2
            ;;
        esac
    done

    while :
    do
        echo -n "Cluster stack backing O2CB [$O2CB_STACK]: "
        read LINE
        case "$LINE" in
        "")
            break
            ;;
        o2cb|heartbeat2)
            O2CB_STACK="$LINE"
            break
            ;;
        cman)
            if [ "$CMAN_SUPPORTED" = "yes" ]
            then
                O2CB_STACK="$LINE"
                break
            fi
            echo "Cluster stack \"$LINE\" not supported" >&2
            ;;
        *)
            echo "Invalid answer: $LINE" >&2
            ;;
        esac
    done

    while :
    do
        echo -n "Cluster to start on boot (Enter \"none\" to clear) [$O2CB_BOOTCLUSTER]: "
        read LINE
        case "$LINE" in
        "")
            break
            ;;
        none)
            O2CB_BOOTCLUSTER=
            break
            ;;

        *[^a-zA-Z0-9]*)
            echo "Invalid cluster name: $LINE" >&2
            ;;
        *)
            O2CB_BOOTCLUSTER="$LINE"
            break
            ;;
        esac
    done

    read_timeout "heartbeat dead threshold" "$O2CB_HEARTBEAT_THRESHOLD" "$MIN_HEARTBEAT_THRESHOLD" "$DEF_HEARTBEAT_THRESHOLD"
    O2CB_HEARTBEAT_THRESHOLD="$RET_VAL"

    read_timeout "network idle timeout in ms" "$O2CB_IDLE_TIMEOUT_MS" "$MIN_IDLE_TIMEOUT_MS" "$DEF_IDLE_TIMEOUT_MS"
    O2CB_IDLE_TIMEOUT_MS="$RET_VAL"

    read_timeout "network keepalive delay in ms" "$O2CB_KEEPALIVE_DELAY_MS" "$MIN_KEEPALIVE_DELAY_MS" "$DEF_KEEPALIVE_DELAY_MS"
    O2CB_KEEPALIVE_DELAY_MS="$RET_VAL"

    read_timeout "network reconnect delay in ms" "$O2CB_RECONNECT_DELAY_MS" "$MIN_RECONNECT_DELAY_MS" "$DEF_RECONNECT_DELAY_MS"
    O2CB_RECONNECT_DELAY_MS="$RET_VAL"

    # XXX ask about mount point base
}


#
# make_dir()
#
# Create $1
# Returns 0 on success, 1 on error, 2 if it already exists.
#
make_dir()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "make_dir(): Requires an argument" >&2
        return 1
    fi
    DIR="$1"
    if [ -e "$DIR" ]
    then
        if [ -d "$DIR" ]
        then
            return 2
        fi
        echo "make_dir(): File $DIR is not a directory" >&2
        return 1
    fi

    echo -n "Creating directory '$DIR': "
    mkdir -p "$DIR" 2>/dev/null
    if [ $? != 0 ]
    then
        echo "Unable to create directory '$DIR'" >&2
        return 1
    fi
    return 0
}


#
# driver_filesystem()
# Check to see if a filesystem driver is loaded.
#
# 0 is loaded, 1 is not.
#
driver_filesystem()
{
    if [ "$#" != "1" -o -z "$1" ]
    then
        echo "driver_filesystem(): Missing an argument" >&2
        exit 1
    fi
    FSNAME="$1"

    FSOUT="`awk '$2 ~ /^'$FSNAME'$/{print $1;exit}' < /proc/filesystems 2>/dev/null`"
    test -n "$FSOUT"
    return $?
}


#
# load_filesystem()
# Load a filesystem driver.
#
# 0 is success, 1 is error, 2 is already loaded.
#
load_filesystem()
{
    if [ "$#" != "1" -o -z "$1" ]
    then
        echo "load_filesystem(): Missing an argument" >&2
        return 1
    fi
    FSNAME="$1"

    driver_filesystem "$FSNAME" && return 2

    echo -n "Loading filesystem \"$FSNAME\": "
    modprobe -s "$FSNAME"
    if [ "$?" != 0 ]
    then
        echo "Unable to load filesystem \"$FSNAME\"" >&2
        return 1
    fi

    return 0
}

#
# unload_filesystem()
# Unload a filesystem driver.  Be careful to notice if the driver is
# built-in and do nothing.
#
# 0 is success, 1 is error, 2 is already loaded.
#
unload_filesystem()
{
    if [ "$#" != "1" -o -z "$1" ]
    then
        echo "unload_filesystem(): Missing an argument" >&2
        return 1
    fi
    FSNAME="$1"

    driver_filesystem "$FSNAME" || return 2

    MODOUT="`awk '$1 ~ /^'$FSNAME'$/{print $1,$3;exit}' < /proc/modules 2>/dev/null`"
    if [ -z "$MODOUT" ]
    then
        # The driver is built in, we can't unload it.
        return 2
    fi

    case "$MODOUT" in
    $FSNAME\ 0)
        ;;
    $FSNAME\ *)
        # The driver is busy, leave it alone
        return 2
        ;;
    *)
        echo -n "Invalid module parsing! "
        return 1
        ;;
    esac

    echo -n "Unloading module \"$FSNAME\": "
    modprobe -rs "$FSNAME"
    if [ "$?" != 0 ]
    then
        echo "Unable to unload module \"$FSNAME\"" >&2
        return 1
    fi

    return 0
}

#
# check_filesystem()
# Check to see if a filesystem of type $1 is mounted at $2.
#
# 0 is mounted, 1 is not.
#
check_filesystem()
{
    if [ "$#" != "2" -o -z "$1" -o -z "$2" ]
    then
        echo "check_filesystem(): Missing arguments" >&2
        exit 1
    fi
    FSNAME="$1"
    MOUNTPOINT="$2"

    FULL_MOUNTSEARCH="`echo "$MOUNTPOINT" | sed -e 's/\//\\\\\//g'`"
    MOUNTOUT="`awk '$2 ~ /^'$FULL_MOUNTSEARCH'$/ && $3 ~ /^'$FSNAME'$/{print $2; exit}' < /proc/mounts 2>/dev/null`"
    test -n "$MOUNTOUT"
    return $?
}

#
# mount_filesystem()
# Mounts a pseudo-filesystem of type $1 on mountpoint $2.  It will
# load the drivers for $1 and create $2 if needed.
#
# 0 is success, 1 is error, 2 is already mounted.
# 
mount_filesystem()
{
    if [ "$#" != "2" -o -z "$1" -o -z "$2" ]
    then
        echo "mount_filesystem(): Missing arguments" >&2
        return 1
    fi
    FSNAME="$1"
    MOUNTPOINT="$2"

    check_filesystem "$FSNAME" "$MOUNTPOINT" && return 2

    load_filesystem "$FSNAME"
    if_fail $?

    # XXX some policy?
    if [ ! -e "$MOUNTPOINT" ]; then
        make_dir $MOUNTPOINT
        if_fail "$?"
    fi

    echo -n "Mounting ${FSNAME} filesystem at ${MOUNTPOINT}: "
    mount -t ${FSNAME} ${FSNAME} ${MOUNTPOINT}
    if [ $? != 0 ]
    then
        echo "Unable to mount ${FSNAME} filesystem" >&2
        return 1
    fi

    return 0
}

#
# unmount_filesystem()
# Unmount a pseudo-filesystem of type $1 from mountpoint $2.  It will
# remove the driver for $1 if it can.
#
# 0 is success, 1 is error, 2 is not mounted
#
unmount_filesystem()
{
    if [ "$#" != "2" -o -z "$1" -o -z "$2" ]
    then
        echo "unmount_filesystem(): Missing arguments" >&2
        return 1
    fi
    FSNAME="$1"
    MOUNTPOINT="$2"

    if check_filesystem "$FSNAME" "$MOUNTPOINT"
    then
        echo -n "Unmounting ${FSNAME} filesystem: "
        umount $MOUNTPOINT
        RC=$?
        if [ $RC != 0 ]
        then
            echo "Unable to unmount ${FSNAME} filesystem" >&2
            return 1
        fi
        if_fail $RC  # For the success string
    fi

    unload_filesystem "$FSNAME"
    return $?
}

#
# status_filesystem()
# Report the status of a filesystem, whether it is mounted or not
#
# 0 is not mounted, 1 is error, 2 is already mounted
#
status_filesystem()
{
    if [ "$#" != "2" -o -z "$1" -o -z "$2" ]
    then
        echo "status_filesystem(): Missing arguments" >&2
        return 1
    fi
    FSNAME="$1"
    MOUNTPOINT="$2"

    echo -n "Driver for \"$FSNAME\": "
    if driver_filesystem "$FSNAME"
    then
        echo "Loaded"
    else
        echo "Not loaded"
        return 0
    fi

    echo -n "Filesystem \"$FSNAME\": "
    if check_filesystem "$FSNAME" "$MOUNTPOINT"
    then
        echo "Mounted"
        return 2
    fi
    echo "Not mounted"
    return 0
} 

#
# check_heartbeat()
#
# 0 is hb not active, 1 is error, 2 is hb active
#
check_heartbeat()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "check_heartbeat(): Requires an argument" >&2
        return 1
    fi
    CLUSTER="$1"

    RC=0
    if [ -d "$(configfs_path)/cluster/${CLUSTER}/heartbeat/" ]
    then
        ls -1 "$(configfs_path)/cluster/${CLUSTER}/heartbeat/" | while read HBUUID
        do
            if [ -d "$(configfs_path)/cluster/${CLUSTER}/heartbeat/${HBUUID}" ]
            then
                return 2;
            fi
        done
        if [ $? = 2 ]
        then
            RC=2
        fi
    fi

    return $RC
}

#
# clean_heartbeat()
# Removes the inactive heartbeat regions
# 
clean_heartbeat()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "clean_heartbeat(): Requires an argument" >&2
        return 1
    fi
    CLUSTER="$1"

    if [ ! -f "$(configfs_path)/cluster/${CLUSTER}/heartbeat/*" ]
    then
        return
    fi

    echo -n "Cleaning heartbeat on ${CLUSTER}: "

    ls -1 "$(configfs_path)/cluster/${CLUSTER}/heartbeat/" | while read HBUUID
    do
        if [ ! -d "$(configfs_path)/cluster/${CLUSTER}/heartbeat/${HBUUID}" ]
        then
            continue
        fi

        OUTPUT="`ocfs2_hb_ctl -I -u ${HBUUID} 2>&1`"
        if [ $? != 0 ]
        then
            echo "Failed"
            echo "${OUTPUT}" >&2
            exit 1
        fi

        REF="`echo ${OUTPUT} | awk '/refs/ {print $2; exit;}' 2>&1`"
        if [ $REF != 0 ]
        then
           echo "Failed"
           echo "At least one heartbeat region still active" >&2
           exit 1
        else
           OUTPUT="`ocfs2_hb_ctl -K -u ${HBUUID} 2>&1`"
        fi
    done
    if [ $? = 1 ]
    then
        exit 1
    fi
    echo "OK"
}

#
# clean_cluster()
# Force cleans configured cluster
#
# 0 is clean, 1 is error, 2 is not clean
#
clean_cluster()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "clean_cluster(): Requires an argument" >&2
        return 1
    fi
    CLUSTER="$1"

    if [ -d "$(configfs_path)/cluster/${CLUSTER}/node/" ]
    then
        ls -1 "$(configfs_path)/cluster/${CLUSTER}/node/" | while read NODE
        do
            rmdir "$(configfs_path)/cluster/${CLUSTER}/node/${NODE}" >/dev/null 2>&1
        done
    fi

    if [ -d "$(configfs_path)/cluster/${CLUSTER}" ]
    then
        rmdir "$(configfs_path)/cluster/${CLUSTER}" >/dev/null 2>&1
    fi

    if [ -d "$(configfs_path)/cluster/${CLUSTER}" ]
    then
        return 2
    fi

    return 0
}

#
# load_heartbeat()
# Load a given heartbeat method and set it to be the active mode.
#
# 0 is success, 1 is error, and 2 is already active.
#
load_heartbeat()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "load_heartbeat(): Requires an argument" >&2
        exit 1 
    fi
    HB_METHOD="$1"
    HB_MODULE="ocfs2_${HB_METHOD}_heartbeat"

    #
    # Older drivers don't have heartbeat_modes.  They're disk
    # heartbeat only.  It's loaded with ocfs2_nodemanager, which is pulled
    # in by loading ocfs2_dlmfs.
    #
    # For a newer driver, if ocfs2_nodemanager is loaded, we'll see
    # heartbeat_mode.  Thus, we can check for the loaded
    # ocfs2_<method>_heartbeat driver below.
    #
    if [ ! -e "$(configfs_path)/cluster/heartbeat_mode" ]
    then
        [ "$HB_METHOD" = "disk" ] && return 2
        echo "Checking for available heartbeat method: "
        echo "Unsupported heartbeat method: $HB_METHOD" >&2
        if_fail 1 "Unsupported heartbeat method: $HB_METHOD"
    fi
    
    CUR_METHOD="$(cat "$(configfs_path)/cluster/heartbeat_mode")"
    [ "$CUR_METHOD" = "$HB_METHOD" ] && return 2

    HBOUT="$(awk '/^'$HB_METHOD'$/{print;exit}' "$(configfs_path)/cluster/heartbeat_available_modes" 2>/dev/null)"
    if [ -z "$HBOUT" ]
    then
        echo -n "Loading module \"${HB_MODULE}\": "
        modprobe -s "$HB_MODULE"
        if [ "$?" != 0 ]
        then
            echo "Unable to load module \"$HB_MODULE\"" >&2
            if_fail 1 "Unable to load module \"$HB_MODULE\""
        fi
        if_fail 0
    fi

    echo -n "Setting heartbeat mode \"$HB_METHOD\": "
    echo "$HB_METHOD" >"$(configfs_path)/cluster/heartbeat_mode" 2>/dev/null
    if_fail $? "Unable to set heartbeat mode \"$HB_METHOD\""
}

#
# unload_heartbeat()
# Unload a given heartbeat method.
#
# 0 is success, 1 is error, and 2 is not loaded.
#
unload_heartbeat()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "unload_heartbeat(): Requires an argument" >&2
        exit 1 
    fi
    HB_METHOD="$1"
    HB_MODULE="ocfs2_${HB_METHOD}_heartbeat"

    #
    # Older drivers don't have heartbeat drivers.  If we can't find
    # the driver module, it might as well be unloaded :-)
    #
    MODOUT="`awk '$1 ~ /^'$HB_MODULE'$/{print $1,$3;exit}' < /proc/modules 2>/dev/null`"
    if [ -z "$MODOUT" ]
    then
        # Either it's not loaded or the driver is built in
        return 2
    fi

    case "$MODOUT" in
    $HB_MODULE\ 0)
        ;;
    $HB_MODULE\ *)
        # The driver is busy, leave it alone
        return 2
        ;;
    *)
        echo -n "Invalid module parsing! "
        exit 1
        ;;
    esac

    echo -n "Unloading module \"$HB_MODULE\": "
    modprobe -rs "$HB_MODULE"
    if [ "$?" != 0 ]
    then
        echo "Unable to unload module \"$HB_MODULE\"" >&2
        if_fail 1 "$Unable to unload module \"$HB_MODULE\""
    fi

    if_fail 0
}

#
# unload_module()
# Unload a module
#
# 0 is success, 1 is error, 2 is not loaded
# 
unload_module()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "unload_module(): Requires an argument" >&2
        return 1
    fi
    MODNAME="$1"

    MODOUT="`awk '$1 ~ /^'$MODNAME'$/{print $1,$3;exit}' < /proc/modules 2>/dev/null`"
    if [ -z "$MODOUT" ]
    then
        return 2
    fi
    case "$MODOUT" in
    $MODNAME\ 0)
        ;;
    $MODNAME\ *)
        return 2
        ;;
    *)
        echo -n "Invalid module parsing! "
        return 1
        ;;
    esac

    echo -n "Unloading module \"$MODNAME\": "
    modprobe -rs "$MODNAME"
    if [ "$?" != 0 ]
    then
        echo "Unable to unload module \"$MODNAME\"" >&2
        return 1
    fi

    return 0
}

#
# check_load_module()
#
# 0 is not loaded, 1 is error, 2 is already loaded
#
check_load_module()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "check_load_module(): Requires an argument" >&2
        return 1
    fi
    MODNAME="$1"

    echo -n "Module \"$MODNAME\": "
    MODOUT="`awk '$1 ~ /^'$MODNAME'$/{print $1,$3;exit}' < /proc/modules 2>/dev/null`"
    if [ -z "$MODOUT" ]
    then
        echo "Not loaded"
        return 0
    fi
    echo "Loaded"
    return 2
}

load()
{
    # XXX: SPECIAL CASE!  We must load configfs for configfs_path() to work
    load_filesystem "configfs"
    if_fail $?

    mount_filesystem "configfs" "$(configfs_path)"
    if_fail $?

    mount_filesystem "ocfs2_dlmfs" "/dlm"
    if_fail $?

    case "$O2CB_STACK" in
        o2cb) load_heartbeat "disk" ;;
        heartbeat2) load_heartbeat "user" ;;
        cman)
            if [ "$CMAN_SUPPORTED" = "yes" ]
            then
                load_heartbeat "user"
            else
                echo "Cluster stack \"${O2CB_STACK}\" not supported" >&2
                exit 1
            fi
            ;;
        *)
            echo "Invalid O2CB_STACK: $O2CB_STACK" >&2
            exit 1
        ;;
    esac

    return 0
}

status_heartbeat()
{
    case "$O2CB_STACK" in
        o2cb) HB_METHOD="disk" ;;
        heartbeat2) HB_METHOD="user" ;;
        cman)
            if [ "$CMAN_SUPPORTED" = "yes" ]
            then
                HB_METHOD="user"
            else
                echo "Cluster stack \"${O2CB_STACK}\" not supported" >&2
                exit 1
            fi
            ;;
        *)
            echo "Invalid O2CB_STACK: $O2CB_STACK" >&2
            exit 1
        ;;
    esac

    echo -n "Heartbeat driver \"$HB_METHOD\": "
    if [ ! -e "$(configfs_path)/cluster" ]
    then
        echo "Not loaded"
        return
    fi
    
    if [ ! -e "$(configfs_path)/cluster/heartbeat_mode" ]
    then
        if [ "$HB_METHOD" = "disk" ]
        then
            echo "Loaded"
        else
            echo "Not supported"
        fi
        return
    fi
    
    CUR_METHOD="$(cat "$(configfs_path)/cluster/heartbeat_mode")"
    if [ "$CUR_METHOD" = "$HB_METHOD" ]
    then
        echo "Loaded"
        return
    fi

    if grep "$HB_METHOD" "$(configfs_path)/cluster/heartbeat_available_modes" >/dev/null 2>&1
    then
        echo "Loaded but not active"
    else
        echo "Not loaded"
    fi
}

load_status()
{
    status_filesystem "configfs" "$(configfs_path)"
    status_filesystem "ocfs2_dlmfs" "/dlm"
    status_heartbeat
}

status_cman()
{
    FOUND=0

    echo -n "Checking for daemons: "
    for d in o2cb_controld ocfs2_controld
    do
        if [ -n "$(pidofproc "/sbin/${d}")" ]
        then
            FOUND=1
            echo -n "${d} "
        fi
    done
    [ "$FOUND" = 0 ] && echo -n "not running"
    echo
}

online_o2cb()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "online_o2cb(): Requires an argument" >&2
        return 1
    fi
    CLUSTER="$1"

    if ! [ -f ${CLUSTERCONF} ]
    then
        echo -n "Checking O2CB cluster configuration : "
        if_fail 1
    fi

    echo -n "Starting O2CB cluster ${CLUSTER}: "
    OUTPUT="`o2cb_ctl -H -n "${CLUSTER}" -t cluster -a online=yes 2>&1`"
    if [ $? = 0 ]
    then
        set_timeouts
        echo "OK"
        return
    else
        echo "Failed"
        echo "$OUTPUT"
    fi

    echo -n "Stopping O2CB cluster ${CLUSTER}: "
    OUTPUT="`o2cb_ctl -H -n "${CLUSTER}" -t cluster -a online=no 2>&1`"
    if_fail "$?" "$OUTPUT"
}

cman_name()
{
    /usr/sbin/cman_tool status 2>/dev/null | awk '/^Cluster Name:/{print $3}'
}

bringup_daemon()
{
    if [ "$#" != 1 -o -z "$1" ]
    then
        echo "bringup_daemon(): Requires an argument" >&2
        return 1
    fi
    DAEMON="$1"

    echo -n "Starting $(basename "$DAEMON"): "
    start_daemon "$DAEMON"
    [ $? != 0 ] && return 1

    COUNT=0
    while [ -z "$(pidofproc "$DAEMON")" ]
    do
        COUNT="$(expr "$COUNT" + 1)"
        if [ "$COUNT" -gt "$BRINGUP_TIMEOUT" ]
        then
            return 1
        fi
        sleep 1
    done

    return 0
}

online_cman()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "online_o2cb(): Requires an argument" >&2
        return 1
    fi
    CLUSTER="$1"

    CMAN_CLUSTER="$(cman_name)"
    if [ -z "$CMAN_CLUSTER" ]
    then
        echo -n "Checking for cman cluster: "
        if_fail 1 "Cman not running"
    fi

    if [ "$CMAN_CLUSTER" != "$CLUSTER" ]
    then
        echo -n "Checking for cluster \"$CLUSTER\": "
        if_fail 1 "Cman cluster is \"$CMAN_CLUSTER\", not \"$CLUSTER\""
    fi

    bringup_daemon /sbin/o2cb_controld
    if_fail $? "Unable to start /sbin/o2cb_controld"
    
    COUNT=0
    while [ ! -d "$(configfs_path)/cluster/${CLUSTER}" ]
    do
        COUNT="$(expr "$COUNT" + 1)"
        if [ "$COUNT" -gt "$BRINGUP_TIMEOUT" ]
        then
            echo -n "Setting timeout values: "
            if_fail 1 "Cluster timeout access not available"
        fi
        sleep 1
    done

    set_timeouts
        
    bringup_daemon /sbin/ocfs2_controld
    if_fail $? "Unable to start /sbin/ocfs2_controld"
}

online()
{
    CLUSTER="${1:-${O2CB_BOOTCLUSTER}}"
    if [ -z "$CLUSTER" ]
    then
        echo "O2CB cluster not known"
        return
    fi

    check_online $CLUSTER
    if [ $? = 2 ]
    then
        echo "O2CB cluster ${CLUSTER} already online"
        return
    fi

    case "$O2CB_STACK" in
        o2cb|heartbeat2) online_o2cb "$CLUSTER" ;;
        cman)
            if [ "$CMAN_SUPPORTED" = "yes" ]
            then
                online_cman "$CLUSTER"
            else
                echo "Cluster stack \"$O2CB_STACK\" not supported" >&2
                exit 1
            fi
            ;;
        *)
            echo "Invalid O2CB_STACK: $O2CB_STACK" >&2
            exit 1
            ;;
    esac

    echo "$O2CB_STACK" >"$STACKCONF" 2>/dev/null
    if [ "$?" != 0 ]
    then
        echo -n "Setting O2CB_STACK file: "
        if_fail $? "Unable to store cluster stack information"
    fi
}

#
# check_online()
#
# 0 is not online, 1 is error, 2 is online
#
check_online()
{
    if [ "$#" -lt "1" -o -z "$1" ]
    then
        echo "check_online(): Requires an argument" >&2
        return 1
    fi
    CLUSTER="$1"

    RC=0
    if [ -d "$(configfs_path)/cluster/${CLUSTER}/node/" ]
    then
        ls -1 "$(configfs_path)/cluster/${CLUSTER}/node/" | while read NODE
        do
            LOCAL="`cat \"$(configfs_path)/cluster/${CLUSTER}/node/${NODE}/local\"`"
            if [ $LOCAL = 1 ]
            then
                return 2
            fi
        done
        if [ $? = 2 ]
        then
            RC=2
        fi
    fi
    return $RC
}

offline_o2cb()
{
    if [ "$#" -lt "2" -o -z "$1" -o -z "$2" ]
    then
        echo "offline_o2cb(): Missing arguments" >&2
        return 1
    fi
    CLUSTER="$1"
    FORCE="$2"

    clean_heartbeat $CLUSTER

    echo -n "Stopping O2CB cluster ${CLUSTER}: "
    check_heartbeat $CLUSTER
    if [ $? != 0 ]
    then
        echo "Failed"
        echo "Unable to stop cluster as heartbeat region still active" >&2
        exit 1
    fi

    if [ $FORCE -eq 1 ]
    then
        clean_cluster $CLUSTER
        if_fail "$?" "Unable to force-offline cluster $CLUSTER" >&2
    else
        OUTPUT="`o2cb_ctl -H -n "${CLUSTER}" -t cluster -a online=no 2>&1`"
        if_fail "$?" "$OUTPUT - Try to force-offline the O2CB cluster"
    fi
}

offline_cman()
{
    if [ "$#" -lt "2" -o -z "$1" -o -z "$2" ]
    then
        echo "offline_o2cb(): Missing arguments" >&2
        return 1
    fi
    CLUSTER="$1"
    FORCE="$2"

    CMAN_CLUSTER="$(cman_name)"
    if [ -z "$CMAN_CLUSTER" ]
    then
        echo -n "Checking for cman cluster: "
        if_fail 1 "Cman not running"
    fi

    if [ "$CMAN_CLUSTER" != "$CLUSTER" ]
    then
        echo -n "Checking for cluster \"$CLUSTER\": "
        if_fail 1 "Cman cluster is \"$CMAN_CLUSTER\", not \"$CLUSTER\""
    fi

    check_heartbeat $CLUSTER
    if [ $? != 0 ]
    then
        echo -n "Stopping O2CB cluster ${CLUSTER}: "
        if_fail 1 "Unable to stop cluster as heartbeat region still active"
    fi
 
    echo -n "Stopping ocfs2_controld: "
    killproc /sbin/ocfs2_controld
    if_fail $? "Unable to stop ocfs2_controld"

    echo -n "Stopping o2cb_controld: "
    killproc /sbin/o2cb_controld
    if_fail $? "Unable to stop o2cb_controld"
}

offline()
{
    CLUSTER="${1:-${O2CB_BOOTCLUSTER}}"
    if [ -z "$CLUSTER" ]
    then
        return
    fi

    if [ $# -gt 1 ]
    then
        FORCE=$2
    else
        FORCE=0
    fi

    if [ ! -e "$(configfs_path)/cluster/${CLUSTER}" ]
    then
        return
    fi

    case "$O2CB_STACK" in
        o2cb|heartbeat2) offline_o2cb "$CLUSTER" "$FORCE" ;;
        cman)
            if [ "$CMAN_SUPPORTED" = "yes" ]
            then
                offline_cman "$CLUSTER" "$FORCE"
            else
                echo "Cluster stack \"${O2CB_STACK}\" not supported" >&2
                exit 1
            fi
            ;;
        *)
            echo "Invalid O2CB_STACK: $O2CB_STACK" >&2
            exit 1
            ;;
    esac

    rm -f "$STACKCONF" 2>/dev/null

    unload_module ocfs2
    if_fail "$?"
}

start()
{
    if [ "$O2CB_ENABLED" != "true" ]
    then
        exit 0
    fi

    load
    online "$1"
}

unload()
{
    if [ -d "$(configfs_path)/cluster/" ]
    then
        ls -1 $(configfs_path)/cluster/ | while read CLUSTER
        do
            if [ ! -L "$(configfs_path)/cluster/${CLUSTER}" -a \
                 -d "$(configfs_path)/cluster/${CLUSTER}" ]
            then
                echo "Unable to unload modules as O2CB cluster ${CLUSTER} is still online" >&2
                exit 1
            fi
        done
        if [ $? = 1 ]
        then
            exit 1
        fi
    fi

    case "$O2CB_STACK" in
        o2cb) unload_heartbeat "disk" ;;
        heartbeat2) unload_heartbeat "user" ;;
        cman)
            if [ "$CMAN_SUPPORTED" = "yes" ]
            then
                unload_heartbeat "user"
            else
                echo "Cluster stack \"${O2CB_STACK}\" not supported" >&2
                exit 1
            fi 
            ;;
        *)
            echo "Invalid O2CB_STACK: $O2CB_STACK" >&2
            exit 1
        ;;
    esac

    unmount_filesystem "ocfs2_dlmfs" "/dlm"
    if_fail $?

    # Only unmount configfs if there are no other users
    if [ -z "$(ls -1 "$(configfs_path)")" ]
    then
        unmount_filesystem "configfs" "/sys/kernel/config"
        if_fail $?
    fi
}

stop()
{
    offline "$1"
    unload
}

configure()
{
    configure_ask
    write_sysconfig
    if_fail "$?" "Unable to write the driver configuration"
}

status()
{
    load_status

    CLUSTER="${1:-${O2CB_BOOTCLUSTER}}"
    if [ -z "$CLUSTER" ]
    then
        return 1;
    fi

    [ "$O2CB_STACK" = "cman" -a "$CMAN_SUPPORTED" = "yes" ] && status_cman

    echo -n "Checking O2CB cluster $CLUSTER: "
    check_online $CLUSTER
    if [ $? = 2 ]
    then
       echo "Online"
    else
       echo "Offline"
       return 0;
    fi

    show_timeouts

    echo -n "Checking O2CB heartbeat: "
    check_heartbeat $CLUSTER
    if [ $? = 2 ]
    then
        echo "Active"
    else
        echo "Not active"
        return 0;
    fi

    return
}



case "$1" in
    start)
        start "$2"
        ;;

    status)
        status "$2"
        ;;

    stop)
        stop "$2"
        ;;

    restart)
        stop "$2"
        start "$2"
        ;;

    force-reload)
        stop "$2"
        start "$2"
        ;;

    load)
        load
        ;;

    online)
        load
        online "$2"
        ;;

    offline)
        offline "$2"
        ;;

    force-offline)
        offline "$2" 1
        ;;

    unload)
        offline "$2"
        unload
        ;;

    configure)
        configure
        if [ "$O2CB_ENABLED" = "true" ]
        then
            start
        else
            stop
        fi
        ;;

    enable)
        O2CB_ENABLED=true
        write_sysconfig
        if_fail "$?" "Unable to write the driver configuration"
        start
        ;;

    disable)
        O2CB_ENABLED=false
        write_sysconfig
        if_fail "$?" "Unable to write the driver configuration"
        stop
        ;;

    *)
        echo "Usage: $0 {start|stop|restart|force-reload|enable|disable|configure|load|unload|online|offline|force-offline|status}"
        exit 1
        ;;
esac

exit 0
